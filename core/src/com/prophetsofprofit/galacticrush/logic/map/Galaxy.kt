package com.prophetsofprofit.galacticrush.logic.map

/**
 * A class that is basically the map that the game is played on
 * Contains a bunch of planets which are essentially the game 'tiles'
 * Planets are connected as a graph rather than sequentially
 */
class Galaxy(numPlanets: Int) {

    //The planets that are in the galaxy: serve as 'tiles' of the game, but are connected as a graph
    val planets = mutableListOf<Planet>()
    //The cosmic highways that are in the galaxy: serve as the 'paths' or 'connections' of the game
    val highways = mutableListOf<CosmicHighway>()

    /**
     * Galaxy constructor generates all the planets and terrain and values and such
     * The algorithm attempts to maximize the spread of the planets probabilistically:
     *  We start with equal probability for any setting in space
     *  For a certain number of cycles, a planet is generated based on the probability of each tile being chosen
     *  Then we can update the probabilities of the tiles to make those close to the new planet less favorable
     *  Probabilities are relative, so we can just add some scalar to each tile's probability based on its distance from
     *  the planet every step
     * While this isn't a world, a good term for this would be 'worldgen'
     */
    init {
        /*
        * The planets are generated by choosing from a finite set of locations arranged in a square grid
        * The side length of that square is worldSize
        * Changing the scalar multiplier in this variable will affect amount of possible locations for planets
        * As a result, the spacing of the planets will change
        * For instance, decreasing the scalar multiplier will make the planets closer together by decreasing the amount of possible locations
        */
        val worldSize = 8 * numPlanets
        //The grid is a flattened array where every worldSize elements represent a row
        val probabilities = Array(worldSize * worldSize, { 1.0 })
        for (i in 0 until numPlanets) {
            //The following code chooses a new location for a planet
            //Create an array where each element is the sum of the first n elements of probabilities
            val cumulativeProbabilities = probabilities.clone()
            for (j in 1 until probabilities.size) {
                cumulativeProbabilities[j] += cumulativeProbabilities[j - 1]
            }
            //Choose a random number between 0 and the sum of all the probabilities
            val chosenCumulative = Math.random() * probabilities.sum()
            //Then the first number greater than that number is the at the index of the chosen planet
            val chosenLocation = cumulativeProbabilities.indexOfFirst { it > chosenCumulative }
            //Because bigger probabilities result in bigger gaps between adjacent elements in the cumulative
            //probabilities list, the chance that a location is chosen is proportional to the fraction of the total sum
            //its probability takes up

            //Setting the probability of that location to 0 ensures we cannot generate new planets there, and it is
            //also useful for determining the final locations of the planets
            probabilities[chosenLocation] = 0.0

            //Update probabilities
            for (j in 0 until probabilities.size) {
                //j / worldSize - j % worldSize is a conversion from the flattened list to a square grid coordinate system where
                //j / worldSize is row and j % worldSize is column
                //We add a scalar factor based on the Manhattan distance between each tile and the new planet to its probability
                //If the tile in question is already a planet, do nothing
                probabilities[j] = if (probabilities[j] != 0.0) probabilities[j] + Math.pow((Math.abs(j / worldSize - chosenLocation / worldSize) + Math.abs(j % worldSize  - chosenLocation % worldSize)).toDouble(), 1.0) else 0.0
            }
        }
        //When we're finished, every coordinate with a zero probability is market for becoming a planet
        //For each one, add a planet to the list of planets after scaling coordinates to be between 0 and 1
        //0.5 / worldSize accounts for the planet being at the center of the square defined by coordinates instead of its corner
        (0 until probabilities.size)
                .filter { probabilities[it] == 0.0 }
                .mapTo(planets) { Planet((it / worldSize).toDouble() / worldSize + 0.5 / worldSize, (it % worldSize).toDouble() / worldSize + 0.5 / worldSize, ((0.15 + Math.random() * 0.35) / worldSize).toFloat()) }
        /**
         * Edge generation:
         * Goes through each planet in a random order and creates cosmic highways (connections) between planets within .2 of world size distance
         * Doesn't create highways that cross other highways TODO: Doesn't work quite perfectly
         */
        for(p0 in planets.shuffled()) {
            for(p1 in planets) {
                //If the distance between the two planets is less than .2, proceed with the operation
                if(Math.sqrt(Math.pow((p0.x - p1.x).toDouble(), 2.0) + Math.pow((p0.y - p1.y).toDouble(), 2.0)) < 0.20) {
                    var isIntersecting = false
                    //Check for an intersection between all existing highways
                    for(i in highways) {
                        if(doSegmentsIntersect(p0.x, p0.y, p1.x - p0.x, p1.y - p0.y, i.p0.x, i.p0.y, i.p1.x - i.p0.x, i.p1.y - i.p0.y)) {
                            isIntersecting = true
                            break
                        }
                    }
                    //If there is no intersection, create a highway between the two planets
                    if(!isIntersecting) {
                        highways.add(CosmicHighway(p0, p1))
                    }
                }
            }
        }
    }

    /**
     * Returns whether or not two line segments intersect
     * For use in edge generation to ensure that edges do not intersect each other
     * Works by finding the intersection point of the two segments extented into lines
     * then checking if the solution point is a part of both segment boundaries
     */
    private fun doSegmentsIntersect(x1: Double, y1: Double, dx1: Double, dy1: Double, x2: Double, y2: Double, dx2: Double, dy2: Double): Boolean {
        val xSoln = ((-1 * (dy2 / dx2) * x2 + y2) - (-1 * (dy1 / dx1) * x1 + y1)) / (dy1 / dx1 - dy2 / dx2)
        val ySoln = ((-(dy1 / dx1) * x1 + y1) - ((dy1 / dx1) / (dy2 / dx2)) * (-(dy2 / dx2) * x2 + y2)) / (1 - ((dy1 / dx1) / (dy2 / dx2)))
        return (xSoln - x1) * (xSoln - (x1 + dx1)) < 0 && (xSoln - x2) * (xSoln - (x2 + dx2)) < 0 && (ySoln - y1) * (ySoln - (y1 + dy1)) < 0 && (ySoln - y2) * (ySoln - (y2 + dy2)) < 0
    }

}
