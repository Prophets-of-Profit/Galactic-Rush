package com.prophetsofprofit.galacticrush.logic.map

import com.prophetsofprofit.galacticrush.logic.base.Base
import com.prophetsofprofit.galacticrush.logic.base.Facility
import com.prophetsofprofit.galacticrush.logic.drone.Drone
import com.prophetsofprofit.galacticrush.logic.drone.DroneId
import kotlin.math.abs
import kotlin.math.pow
import kotlin.math.sqrt

/**
 * A class that is basically the map that the game is played on
 * Contains a bunch of planets which are essentially the game 'tiles'
 * Planets are connected as a graph rather than sequentially
 */
class Galaxy(numPlanets: Int, playerIDs: List<Int>) {

    //The planets that are in the galaxy: serve as 'tiles' of the game, but are connected as a graph
    val planets = Array(numPlanets) { Planet(it) }
    //The cosmic highways that are in the galaxy: serve as the 'paths' or 'connections' of the game
    val highways = mutableListOf<CosmicHighway>()
    //The drones that currently exist in the game; should be ordered in order of creation
    val drones: Array<Drone>
        get() {
            return this.planets.fold(mutableListOf<Drone>()) { list, currentPlanet -> list.addAll(currentPlanet.drones); list }.sortedBy { it.creationTime }.toTypedArray()
        }
    //The bases that currently exist in the game; ordered arbitrarily
    val bases: Array<Base>
        get() = this.planets.mapNotNull { it.base }.toTypedArray()

    /**
     * Empty constructor for serialization
     */
    constructor() : this(2, listOf())

    /**
     * Galaxy constructor generates all the planets and terrain and values and such
     * Constructor works by evenly distributing planets across a square grid that has one
     * bounding box for each planet to be generated
     * Afterward, edges are generated by making all edges that are within
     * the side length of the bounding boxes used to generate the planets
     */
    init {
        val minDistanceBetweenHomes = 0.5
        val mainSystem = mutableListOf(this.planets.first())
        val choices = this.planets.toMutableList().also { it.removeAt(0) }
        do {
            this.highways.add(CosmicHighway(choices.first().id, mainSystem.shuffled().first().id))
            mainSystem.add(choices.first())
            choices.removeAt(0)
        } while (choices.isNotEmpty())
        for (planet in this.planets) {
            var thresholdProbability = 0.15
            while (Math.random() < thresholdProbability) {
                thresholdProbability -= 0.05
                val randomPlanetId = this.planets.toMutableList().shuffled().firstOrNull { !this.highways.any { highway -> highway.connects(planet.id) == it.id } }?.id
                if (randomPlanetId != null) {
                    this.highways.add(CosmicHighway(planet.id, randomPlanetId))
                }
            }
        }
        while (this.iterateForces(0.005f, 1f, 0.00005f, 0.05f).values.count { abs(it[0]) > 0.0001 || abs(it[1]) > 0.0001 } > 0) {
        }
        val pickablePlanets = this.planets.toMutableList()
        var planetChoice: Planet
        for (i in 0 until playerIDs.size) {
            do {
                planetChoice = pickablePlanets.shuffled()[0]
            } while (this.planets.any { it.base?.facilityHealths?.containsKey(Facility.HOME_BASE) == true && sqrt((it.x - planetChoice.x).pow(2) + (it.y - planetChoice.y).pow(2)) < minDistanceBetweenHomes })
            planetChoice.base = Base(playerIDs[i], planetChoice.id, arrayOf(Facility.HOME_BASE, Facility.CONSTRUCTION, Facility.PROGRAMMING))
            pickablePlanets.remove(planetChoice)
        }
    }

    /**
     * Pushes planets away from non-connected planets and toward connected planets
     * Adapted from McGuffin, Michael J. Simple Algorithms for Network Visualization: A Tutorial. Tsinghua Science and Technology
     * @param awayStrength the strength of forces away from planets not connected to a given planet
     * @param towardStrength the strength of forces toward planets connected to a given planet
     */
    fun iterateForces(restingLength: Float, delta: Float, awayStrength: Float = 1f, towardStrength: Float = 1f): MutableMap<Planet, Array<Float>> {
        //TODO: Change
        val movementQueue = this.planets.map { planetToMove -> planetToMove to arrayOf(0f, 0f) }.toMap().toMutableMap()
        //Apply repulsive force between planets
        for (planetIndex1 in 0 until this.planets.size - 1) {
            val planet1 = this.planets[planetIndex1]
            for (planetIndex2 in planetIndex1 + 1 until this.planets.size) {
                val planet2 = this.planets[planetIndex2]
                val dx = planet1.x - planet2.x
                val dy = planet1.y - planet2.y
                if (dx != 0f || dy != 0f) {
                    val distanceSquared = dx * dx + dy * dy
                    val distance = sqrt(distanceSquared)
                    val force = awayStrength / distanceSquared
                    val fx = force * dx / distance
                    val fy = force * dy / distance
                    movementQueue[planet1]!![0] += fx
                    movementQueue[planet1]!![1] += fy
                    movementQueue[planet2]!![0] -= fx
                    movementQueue[planet2]!![1] -= fy
                } else {
                    movementQueue[planet1]!![0] += 0.0001f
                    movementQueue[planet1]!![1] += 0.0001f
                    movementQueue[planet2]!![0] -= 0.0001f
                    movementQueue[planet2]!![1] -= 0.0001f
                }
            }
        }
        //Apply spring force between connected planets
        for (planet1 in this.planets) {
            for (planet2 in this.planetsAdjacentTo(planet1.id).map { this.getPlanetWithId(it) }) {
                val dx = planet1.x - planet2!!.x
                val dy = planet1.y - planet2.y
                if (dx != 0f || dy != 0f) {
                    val distance = sqrt(dx * dx + dy * dy)
                    val force = towardStrength * (distance - restingLength)
                    val fx = force * dx / distance
                    val fy = force * dy / distance
                    movementQueue[planet1]!![0] -= fx
                    movementQueue[planet1]!![1] -= fy
                }
            }
        }
        //Apply spring force to center
        for (planet in this.planets) {
            val distance = sqrt((planet.x - 0.5f) * (planet.x - 0.5f) + (planet.y - 0.5f) * (planet.y - 0.5f))
            if (distance >= 0.1f) {
                val force = towardStrength * (distance - 0.1f)
                val fx = force * (planet.x - 0.5f) / distance
                val fy = force * (planet.y - 0.5f) / distance
                movementQueue[planet]!![0] -= fx
                movementQueue[planet]!![1] -= fy
            }
        }
        //Apply movement
        for (planet in this.planets) {
            planet.x += movementQueue[planet]!![0] * delta
            planet.y += movementQueue[planet]!![1] * delta
        }
        return movementQueue
    }

    /**
     * Returns all highways connected to the planet with the specified ID
     */
    fun highwaysConnectedTo(id: Int): Array<CosmicHighway> {
        return this.highways.filter { it.connects(id) != null }.toTypedArray()
    }

    /**
     * Gets al planets adjacent to the given planet
     */
    fun planetsAdjacentTo(id: Int): Array<Int> {
        return this.highways.mapNotNull { it.connects(id) }.toTypedArray()
    }

    /**
     * Gets the planet with a specified ID
     */
    fun getPlanetWithId(id: Int): Planet? {
        return this.planets.firstOrNull { it.id == id }
    }

    /**
     * Gets the drone with the specified drone information
     */
    fun getDroneWithId(id: DroneId?): Drone? {
        return this.drones.firstOrNull { it.id == id }
    }

}
