package com.prophetsofprofit.galacticrush.logic.map

import com.badlogic.gdx.math.Intersector
import com.badlogic.gdx.math.Vector2
import com.prophetsofprofit.galacticrush.logic.base.Base
import com.prophetsofprofit.galacticrush.logic.base.Facility
import com.prophetsofprofit.galacticrush.logic.drone.Drone
import com.prophetsofprofit.galacticrush.logic.drone.DroneId
import com.prophetsofprofit.galacticrush.logic.loot.selectLoot
import com.prophetsofprofit.galacticrush.maxLoot
import com.prophetsofprofit.galacticrush.minLoot
import java.util.*
import kotlin.math.*

/**
 * A class that is basically the map that the game is played on
 * Contains a bunch of planets which are essentially the game 'tiles'
 * Planets are connected as a graph rather than sequentially
 */
class Galaxy(numPlanets: Int, playerIDs: List<Int>) {

    //The planets that are in the galaxy: serve as 'tiles' of the game, but are connected as a graph
    val planets = mutableListOf<Planet>()
    //The planet ids
    val planetIds: List<Int>
        get() = this.planets.map { it.id }
    //The cosmic highways that are in the galaxy: serve as the 'paths' or 'connections' of the game
    val highways = mutableListOf<CosmicHighway>()
    //The drones that currently exist in the game; should be ordered in order of creation
    val drones: Array<Drone>
        get() {
            return this.planets.fold(mutableListOf<Drone>()) { list, currentPlanet -> list.addAll(currentPlanet.drones); list }.sortedBy { it.creationTime }.toTypedArray()
        }
    //The bases that currently exist in the game; ordered arbitrarily
    val bases: Array<Base>
        get() = this.planets.mapNotNull { it.base }.toTypedArray()

    /**
     * Empty constructor for serialization
     */
    constructor() : this(-1, listOf())

    /**
     * Galaxy constructor generates all the planets and terrain and values and such
     * Constructor works by evenly distributing planets across a square grid that has one
     * bounding box for each planet to be generated
     * Afterward, edges are generated by making all edges that are within
     * the side length of the bounding boxes used to generate the planets
     */
    init {
        val minDistanceBetweenHomes = 0.5
        generatePlanets(numPlanets, 0.2)
        var counter = 0
        while (this.iterateForces(0.05f, 1f, 0.0005f, 0.05f).values.count { abs(it[0]) > 0.0001 || abs(it[1]) > 0.0001 } > 0 && ++counter > 0) {
        }
        val pickablePlanets = this.planets.toMutableList()
        var planetChoice: Planet
        for (i in 0 until playerIDs.size) {
            do {
                planetChoice = pickablePlanets.shuffled()[0]
            } while (this.planets.any { it.base?.facilityHealths?.containsKey(Facility.HOME_BASE) == true && sqrt((it.x - planetChoice.x).pow(2) + (it.y - planetChoice.y).pow(2)) < minDistanceBetweenHomes })
            planetChoice.base = Base(playerIDs[i], planetChoice.id, arrayOf(Facility.HOME_BASE, Facility.CONSTRUCTION, Facility.PROGRAMMING))
            pickablePlanets.remove(planetChoice)
        }
        //Give each planet loot
        for (planet in pickablePlanets) {
            for (i in 0 until (minLoot + (maxLoot - minLoot) * Math.random()).toInt()) {
                planet.loot.add(selectLoot())
            }
        }
    }

    /**
     * Generates planets
     */
    private fun generatePlanets(numPlanets: Int, edgeProbabilityFactor: Double) {
        for (i in 0 until numPlanets) {
            val planet = Planet(
                    0.4995f + 0.001f * Math.random().toFloat(),
                    0.4995f + 0.001f * Math.random().toFloat(),
                    0.5f + Math.random().toFloat(),
                    i
            )
            //Add edges
            //The first edge is guaranteed to be created
            var probability = 1.0
            while(this.planetIds.toMutableSet().minus(this.planetsAdjacentTo(i)).isNotEmpty()) {
                if (Math.random() > probability)
                    break
                //Adjust probability
                probability *= edgeProbabilityFactor
                //Add edge; consider refactoring
                val adjacentPlanet = this.planetIds.toMutableSet().minus(this.planetsAdjacentTo(i))
                        .toMutableList().shuffled().first()
                this.highways.add(CosmicHighway(i, adjacentPlanet))
            }
            this.planets.add(planet)
        }
    }

    /**
     * Pushes planets away from non-connected planets and toward connected planets
     * Adapted from McGuffin, Michael J. Simple Algorithms for Network Visualization: A Tutorial. Tsinghua Science and Technology
     * @param awayStrength the strength of forces away from planets not connected to a given planet
     * @param towardStrength the strength of forces toward planets connected to a given planet
     */
    fun iterateForces(restingLength: Float, delta: Float, awayStrength: Float = 1f, towardStrength: Float = 1f): MutableMap<Planet, Array<Float>> {
        //TODO: Change
        val movementQueue = this.planets.map { planetToMove ->
            planetToMove to arrayOf(0f, 0f)
        }.toMap().toMutableMap()
        //Apply repulsive force between planets
        for (planetIndex1 in 0 until this.planets.size - 1) {
            val planet1 = this.planets[planetIndex1]
            for (planetIndex2 in planetIndex1 + 1 until this.planets.size) {
                val planet2 = this.planets[planetIndex2]
                val dx = planet1.x - planet2.x
                val dy = planet1.y - planet2.y
                if (dx != 0f || dy != 0f) {
                    val distanceSquared = dx * dx + dy * dy
                    val distance = sqrt(distanceSquared)
                    val force = awayStrength / distanceSquared
                    val fx = force * dx / distance
                    val fy = force * dy / distance
                    movementQueue[planet1]!![0] += fx
                    movementQueue[planet1]!![1] += fy
                    movementQueue[planet2]!![0] -= fx
                    movementQueue[planet2]!![1] -= fy
                } else {
                    movementQueue[planet1]!![0] += 0.0001f
                    movementQueue[planet1]!![1] += 0.0001f
                    movementQueue[planet2]!![0] -= 0.0001f
                    movementQueue[planet2]!![1] -= 0.0001f
                }
            }
        }
        //Apply spring force between connected planets
        for (planet1 in this.planets) {
            for (planet2 in this.planetsAdjacentTo(planet1.id).map { this.getPlanetWithId(it) }) {
                val dx = planet1.x - planet2!!.x
                val dy = planet1.y - planet2.y
                if (dx != 0f || dy != 0f) {
                    val distance = sqrt(dx * dx + dy * dy)
                    val force = towardStrength * (distance - restingLength)
                    val fx = force * dx / distance
                    val fy = force * dy / distance
                    movementQueue[planet1]!![0] -= fx
                    movementQueue[planet1]!![1] -= fy
                }
            }
        }
        //Apply spring force to center
        for (planet in this.planets) {
            val distance = sqrt((planet.x - 0.5f) * (planet.x - 0.5f) + (planet.y - 0.5f) * (planet.y - 0.5f))
            if (distance >= 0.1f) {
                val force = towardStrength * (distance - 0.1f)
                val fx = force * (planet.x - 0.5f) / distance
                val fy = force * (planet.y - 0.5f) / distance
                movementQueue[planet]!![0] -= fx
                movementQueue[planet]!![1] -= fy
            }
        }
        //Apply movement
        for (planet in this.planets) {
            planet.x += movementQueue[planet]!![0] * delta
            planet.y += movementQueue[planet]!![1] * delta
        }
        return movementQueue
    }

    /**
     * Returns whether an intersection happens that isn't an intersection at the endpoints
     * Segments are p0 -> p1 and p2 -> p3
     */
    private fun doSegmentsIntersect(p0x: Float, p0y: Float, p1x: Float, p1y: Float, p2x: Float, p2y: Float, p3x: Float, p3y: Float): Boolean {
        val intersectionPoint = Vector2()
        val intersect = Intersector.intersectSegments(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, intersectionPoint)
        //Returns whether it intersects and that the intersection point isn't an endpoint
        return intersect && !(
                (intersectionPoint.x == p0x && intersectionPoint.y == p0y) ||
                        (intersectionPoint.x == p1x && intersectionPoint.y == p1y) ||
                        (intersectionPoint.x == p2x && intersectionPoint.y == p2y) ||
                        (intersectionPoint.x == p3x && intersectionPoint.y == p3y)
                )
    }

    /**
     * Returns whether or not the angle between the two given segments is too slim
     * The threshhold is defined as pi / 6 radians (30 degrees)
     */
    private fun isAngleTooSmall(p0x: Float, p0y: Float, p1x: Float, p1y: Float, p2x: Float, p2y: Float, p3x: Float, p3y: Float): Boolean {
        var angleBetween = (atan2(p1y - p0y, p1x - p0x) - atan2(p3y - p2y, p3x - p2x)) % PI
        if (angleBetween < 0) angleBetween += PI
        return angleBetween < PI / 6
    }

    /**
     * Returns all highways connected to the planet with the specified ID
     */
    fun highwaysConnectedTo(id: Int): Array<CosmicHighway> {
        return this.highways.filter { it.connects(id) != null }.toTypedArray()
    }

    /**
     * Gets al planets adjacent to the given planet
     */
    fun planetsAdjacentTo(id: Int): Array<Int> {
        return this.highways.mapNotNull { it.connects(id) }.toTypedArray()
    }

    /**
     * Gets the planet with a specified ID
     */
    fun getPlanetWithId(id: Int): Planet? {
        return this.planets.firstOrNull { it.id == id }
    }

    /**
     * Gets the drone with the specified drone information
     */
    fun getDroneWithId(id: DroneId?): Drone? {
        return this.drones.firstOrNull { it.id == id }
    }

}
